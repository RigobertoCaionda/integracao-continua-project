# Nome do workflow (Escolha minha)
name: ci-golang-workflow

#on: [pull_request] # on: [push] = O processo vai rodar quando um push for feito. Se quisessemos que rodasse quando alguém fizer pull request, então seria on: [pull_request]. Desse jeito roda para qualquer branch, do jeito abaixo podemos escolher a branch.

on: 
  # on pull_request quer dizer que esse processo vai acontecer quando tiver um pull request
  pull_request:
    # Quer dizer que o processo vai acontecer num pull request e nas branches abaixo, nesse caso isso só vai acontecer na branch develop.
    branches:
      - develop

# jobs são as tarefas que o meu workflow vai rodar
jobs:
  # check-application é o nome do primeiro job que o workflow vai rodar
  check-application:
    # runs-on define em qual máquina esse job vai rodar, no nosso caso aqui, o job check-application vai rodar no ubuntu-latest
    runs-on: ubuntu-latest

    # Usamos essa strategy se quisermos testar o projeto em mais de uma versão, só quando queremos isso , nesse caso mais de uma versão do go.
    #strategy:
  # Para testar em mais de uma versão usamos matrix, o nome da linguagem e as versões que queremos.
      #matrix:
        #go: ['1.14', '1.15']

    # Steps são as etapas que o job vai cumprir
    steps:
      # Dentro de step você pode usar uma action tua com o comando run, exemplo:  - run: echo "Olá CI" ou você pode usar uma action que uma outra pessoa criou (E pode ser achada dentro do github actions) usando o comando uses
      # Essa action actions/checkout@v2 é usada para qualquer projeto, pois ela simplesmente clona o teu repositório para dentro da máquina virtual que você criou, a fim de possibilitar os testes que você vai querer executar.
     - uses: actions/checkout@v2
     # essa action setup-go@v2 faz o seguinte, instala go na tua máquina e instala a versão correta do go que precisas.
     # Se o projeto fosse node, usariamos uma action de setup do node que instalaria o node e configuraria uma versão correta do node pois sem node/go na máquina não daria para exceutar as coisas
     - uses: actions/setup-go@v2
       # with go-version 1.15 estamos especificando a versão do go que vamos usar na máquina, assim fariamos também no node.

    # - run: npm install: Se o projeto fosse node faltaria esse passo para instalar as dependências na máquina virtual antes de rodar o projeto e os testes
       with: 
        # O matrix.go está apontando para as versões 1.14 e 1.15, quer dizer que estamos testando nossa aplicação nessas duas  versões
        #go-version: ${{ matrix.go }}
        go-version: 1.15
    # run go test está a rodar os testes da aplicação (Forma de rodar em go) e se der erro a github actions falha
     - run: go test
    # run go run math.go está a rodar a aplicação (Forma de rodar em go) e se der erro a github actions falha
     - run: go run math.go

      # Daqui para baixo tem o propósito de fazer o build da imagem do projeto
     - name: Set QEMU
       uses: docker/setup-qemu-action@v1

     - name: Set up Docker Buildx
       uses: docker/setup-buildx-action@v1

     - name: Build and Push
      # Quando você coloca id, você consegue pegar o resultado dessa action e usar em um outro step
       id: docker_build
       uses: docker/build-push-action@v2
       with:
        # Esse push indica se a imagem será enviada para o dockerhub ou não, se você colocar true, ele vai tentar enviar a imagem para o dockerhub, aí você precisa de colocar a autenticação nesse arquivo, se você colocar false, ele vai apenas fazer o build, mas não vai mandar para o dockerhub
        push: false
        # Esse rigobertocaionda/integracao-continua será o nome da imagem na máquina virtual que criaremos temporariamente
        tags: rigobertocaionda/integracao-continua:latest